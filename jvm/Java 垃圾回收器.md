# 垃圾回收器如何工作
---

## 如何高效的在堆上分配对象空间

java在堆上分配对象，在堆栈上分配指向对象的引用及常量。java从堆分配空间的速度可以和其它程序在堆栈上分配分配空间的速度相媲美。只是因为在分配堆空间时java只是简单的将“堆指针”移动到尚未分配的区域，他是如何做到的呢？
这得益于java的垃圾回收器的工作原理，gc在工作的时候一边回收空间，一边将堆中的对象重新紧凑的排列，这样“堆指针”就可以更容易的移到空闲区域的开始处，也就尽量避免了页面错误。通过gc对对象重新排列，实现了一种高速的、有无限空间可供分配的堆模型。

## 垃圾回收的思想

> 对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区中的引用。

基于此从堆栈和静态存储区开始遍历所有的引用，就能找到所有“活”的对象，对这些对象进行标记，将其余的对象回收。不同的虚拟机对这个过程有不同的具体实现。

1. 停止-复制模式
先暂停程序运行（不属于后台回收模式），将所有活得对象从当前堆复制到另一个堆，没有复制的对象都当作垃圾回收，复制到新堆时对象会被一个挨着一个整齐的排列，这样便可以按照前面说的移动“堆指针”的方式直接分配新空间了。当然这种“复制移动”式的回收方法效率较低，通常做法是按需从堆中分配几块较大的内存，复制动作发生在这几块较大的内存之间。

2. 标记-清扫模式
前一种“停止-复制”模式在垃圾较少的情况下效率仍然很低下，因为这时大量的复制行为其实没有必要，于是另一种新的方法：遍历所有引用进而找到所有存活的对象并对其标记，标记完成以后将没有标记的对象清理，这个过程中并不做任何复制。当然这样的话剩下的堆空间并不是连续的。

两种方式个有利弊，一般java虚拟机会采用一种自适应的方式，即如果监控到所有对象都很稳定垃圾回收器效率较低时，切换到“标记-清扫模式”，同样监控发现堆空间出现很多碎片时又切回“停止-复制”模式。